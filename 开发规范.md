# Web开发规范 - 避免常见问题

## 1. 缓存问题解决方案

### A. 前端防缓存策略

#### 1. HTML Meta标签（开发阶段）
```html
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
```

#### 2. 动态时间戳版本号
```html
<script>
    const timestamp = new Date().getTime();
    const script = document.createElement('script');
    script.src = `script.js?t=${timestamp}`;
    document.head.appendChild(script);
</script>
```

#### 3. 开发者工具设置
- Chrome DevTools: Network标签 → 勾选"Disable cache"
- 强制刷新快捷键：
  - Windows: Ctrl + Shift + R
  - Mac: Cmd + Shift + R

### B. 后端防缓存HTTP头

```cpp
// C++ Crow框架示例
res.set_header("Cache-Control", "no-store, no-cache, must-revalidate, max-age=0");
res.set_header("Pragma", "no-cache");
res.set_header("Expires", "0");
```

### C. 生产环境缓存策略

```javascript
// 使用文件内容哈希作为版本号
const fileHash = calculateFileHash(content);
script.src = `script.js?v=${fileHash}`;
```

## 2. 媒体元素最佳实践

### A. 明确用途选择元素

| 用途 | 推荐元素 | 原因 |
|------|----------|------|
| 静态图像显示 | `<img>` | 简单、高效 |
| 视频流播放 | `<video>` | 支持流媒体 |
| 动态图像序列 | `<canvas>` | 完全控制 |
| JPEG帧序列 | `<img>` | 本项目的情况 |

### B. 统一媒体显示组件

```javascript
class MediaDisplay {
    constructor(elementId) {
        this.element = document.getElementById(elementId);
        this.currentBlobUrl = null;
    }
    
    displayFrame(blob) {
        const url = URL.createObjectURL(blob);
        
        // 清理之前的URL
        if (this.currentBlobUrl) {
            URL.revokeObjectURL(this.currentBlobUrl);
        }
        
        // 预加载图像
        const tempImg = new Image();
        tempImg.onload = () => {
            this.element.src = url;
            this.currentBlobUrl = url;
            
            // 延迟清理
            setTimeout(() => {
                if (this.currentBlobUrl === url) {
                    URL.revokeObjectURL(url);
                    this.currentBlobUrl = null;
                }
            }, 100);
        };
        
        tempImg.onerror = () => {
            console.error('Failed to load image frame');
            URL.revokeObjectURL(url);
        };
        
        tempImg.src = url;
    }
}
```

### C. Blob URL管理规则

1. **立即清理原则**：创建新URL时清理旧URL
2. **延迟释放**：给浏览器100ms时间显示图像
3. **错误处理**：加载失败时立即释放URL
4. **状态跟踪**：使用变量跟踪当前URL状态

## 3. 调试技巧

### A. 缓存调试
```javascript
// 在控制台验证资源加载
console.log('Script loaded at:', new Date().toISOString());

// 检查资源URL
console.log('Current script src:', document.querySelector('script[src*="script.js"]').src);
```

### B. 媒体调试
```javascript
// 监控blob URL创建和释放
const originalCreateObjectURL = URL.createObjectURL;
const originalRevokeObjectURL = URL.revokeObjectURL;

URL.createObjectURL = function(blob) {
    const url = originalCreateObjectURL.call(this, blob);
    console.log('Created blob URL:', url);
    return url;
};

URL.revokeObjectURL = function(url) {
    console.log('Revoked blob URL:', url);
    return originalRevokeObjectURL.call(this, url);
};
```

## 4. 开发工作流建议

### A. 开发阶段
1. 禁用所有缓存
2. 使用时间戳版本号
3. 经常硬刷新测试

### B. 测试阶段
1. 启用缓存测试正常流程
2. 验证版本更新机制
3. 测试不同浏览器

### C. 生产部署
1. 使用文件哈希版本号
2. 设置合理的缓存策略
3. 监控资源加载性能

## 5. 常见错误及解决方案

### 错误1: `ERR_FILE_NOT_FOUND` for blob URLs
**原因**: URL在图像加载前被释放
**解决**: 使用延迟释放策略

### 错误2: 缓存导致代码不更新
**原因**: 浏览器缓存静态资源
**解决**: 添加时间戳或禁用缓存

### 错误3: video元素无法显示JPEG
**原因**: video元素不支持静态图像
**解决**: 改用img元素或canvas

## 6. 项目特定规范

本项目特点：
- 后端发送JPEG图像帧
- 前端需要实时显示
- 使用WebSocket传输

推荐方案：
- 使用`<img>`元素显示帧
- 统一的`displayImageFrame`方法
- 时间戳防缓存策略 